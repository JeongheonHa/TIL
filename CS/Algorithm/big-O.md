# 빅오 표기법

## 1. 빅오 란?
빅오는 입력값이 무한대로 향할 때 함수의 `상한`을 설명하는 수학적 `표기 방법`이다. 

빅오는 입력값이 커질 때 알고리즘의 실행 시간(`시간 복잡도`)과 함께 공간 요구사항(`공간 복잡도`)이 어떻게 증가하는지를 분류하는데 사용된다. </br> 
또한, 빅오는 `점근적 실행 시간`을 표기할 때 가장 널리 쓰이는 수학적 표기법 중 하나이다.

`점근적 실행 시간`이란 무엇일까 ?
- **입력값이 무한대를 향할 때 함수의 실행 시간의 추이를 의미한다.** </br>

입력값이 충분히 큰 값이 아닌 적은 값일 때 어떤 알고리즘을 사용하더라도 성능의 차이는 거의 없을 것이기 때문에 
- **모든 입력값은 무한대를 향한다고 가정하자.**

또한, 컴퓨터의 경우 실행 시간의 추이에 영향을 주는 요소는 상당히 많다. 그렇기 때문에 
- **실행 시간의 기준은 `연산 수`로 정한다.**
> 이 말은 즉, 실행 시간이 오래 걸린다는 말은 컴퓨터가 연산해야할 수가 많아진다는 것을 의미한다.

이제 빅오를 표기하는 방법에 대해서 알아보자.

빅오는 점근적 실행 시간을 표기할 때 사용한다고 앞서 말했다. 이 말은 곧 정확한 실행 시간을 표현하는 것이 아닌 `대략적인 시간의 추이`를 확인하는 것을 목적으로한다는 것이다.

그렇기 때문에, 빅오로 시간 복잡도를 표현할 때는 
- **`최고차항만을 표기`하며, `계수는 무시`한다.**

빅오가 무엇인지 대해 알아보았으니 이제 빅오에 어떤 것들이 있는지 알아보자.

- `O(1)` : 입력값이 아무리 커도 실행 시간은 `일정`하다. 찾을 수 만있다면 최고의 알고리즘이다.</br>
ex) 해시 테이블의 조회 및 삽입

- `O(log n)` : 여기서부터 실행 시간은 입력값에 영향을 받는다. 하지만 웬만한 n의 크기에 대해서도 매우 견고하다.</br>
ex) 이진 검색

- `O(n)` : 알고리즘을 수행하는데 걸리는 시간은 입력값에 `비례`한다. 이러한 알고리즘을 선형 시간 알고리즘이라고 한다.</br>
ex) 정렬되지 않은 리스트에서 최대값 or 최소값을 찾는 경우

- `O(n log n)` : 대부분의 효율 좋은 정렬 알고리즘이 이에 해당한다. 모든 수에 대해 한 번 이상은 비교해야 하는 비교 기반 정렬 알고리즘은 이 보다 빠를 수 없다.</br>
ex) 병합 정렬

- `O(n^2)` : 비효율적인 정렬 알고리즘이 이에 해당한다.</br>
ex) 버블 정렬

- `O(2^n)` : 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당한다.</br>
ex) 재귀

- `O(n!)` : 가장 느린 알고리즘으로, 입력값이 조금만 커져도 웬만한 다항시간 내에는 계산이 어렵다.</br>
ex) 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제를 브루트 포스로 풀이할 경우

> log의 밑은 2이다.

<img src="https://user-images.githubusercontent.com/108064146/189667189-fb9ad71f-e455-4eca-a1c3-f41fbb92fa31.jpeg"/>

## 2. 시간 복잡도와 공간 복잡도
- `시간 복잡도` : 어떤 알고리즘을 수행하는데 걸리는 `시간`을 설명하는 계산 복잡도
    + 계산 복잡도를 표기하는 방법이 `빅오`인 셈이다.
- `공간 복잡도` : 어떤 알고리즘을 수행하는데 사용되는 `메모리 양`

알고리즘은 흔히 시간과 공간이 `트레이드 오프관계`라고 하는데 이는 실행 시간이 빠른 알고리즘은 공간을 많이 사용하고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다는 소리이다.

## 3. 상한과 최악

**`상한`을 `최악`의 경우와 혼동하지 말자.** 빅오 표기법은 말 그대로 표기 방법이고, 최악의 경우/평균적인 경우의 시간 복잡도와는 아무런 관계가 없는 개념이다.

- `빅오` : `상한`을 의미
- `빅오메가` : `하한`을 의미
- `빅세타` : `평균`을 의미

빅오 표기는 복잡한 함수f(n)이 있을 경우, 이 함수의 실행 시간이 가장 늦을 때(상한), 빠를 때(하한)를 표기한 것이다.


`최악`이란 ?

- **같은 크기의 입력 값에서 가장 연산수가 많은 경우를 말한다.**

예를 들자면, 퀵 정렬의 경우 입력값 [1, 4, 3, 7, 8, 6, 5]가 있을 때 퀵 정렬의 로무토 파티션에서 이 입력값은 최선의 경우에 해당한다. 이 경우 정렬하기 위해서는 총 18번의 비교 또는 스왑 연산이 필요한데 n = 7이니 O(n log n)에 가깝다.

반면, 입력값이 [1, 2, 3, 4, 5, 6, 7 ]이라면 48번의 연산을 수행해야한다. 이 경우가 바로 최악의 경우며 O(n^2)에 가깝다.


이 밖에도 `최선`과 `평균`이 있는데 각각 연산수가 가장 적은 경우, 평균인 경우를 말한다.

빅오에 대해서 다시 설명하자면

- **빅오 표기법은 주어진 경우(최선/최악/평균)의 수행시간의 상한을 나타낸다.** 

## 4. 분할 상환 분석
시간 또는 메모리를 분석하는 알고리즘의 복잡도를 계산할 때, 알고리즘 전체를 보지 않고 최악의 경우만을 살펴보는 것은 지나치게 비관적인 이유로 등장하게 되었다.

- **최악의 경우를 여러 번에 걸쳐 골고루 나눠주는 형태로 알고리즘의 시간 복잡도를 계산한다.**

## 5. 병렬화
일부 알고리즘들은 병렬화로 실행 속도를 높일 수 있으며, 대표적으로 GPU가 있다. GPU는 각각의 코어가 CPU보다 훨씬 느리지만 GPU의 코어는 수천여 개로 구성되어 있어 CPU보다 수백 배 더 많은 연산을 동시에 수행할 수 있다.

## 꿀팁
각 알고리즘 유형마다 최악의 경우에도 수행이 가능한 상한일 때의 실행 시간 추이를 빅오로 표기하며 해당 알고리즘 유형의 최대 연산수를 예측 할 수 있다. 이에 해당 연산수를 넘지 않도록 코드를 짜야한다.


# References
> 파이썬 알고리즘 인터뷰 - 박상길 </br>
> <https://noahlogs.tistory.com/27>
