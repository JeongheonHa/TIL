## IP 
- 클라이언트가 ip주소를 부여받아야하며 지정한 ip(서버)로 패킷이라는 통신 단위로 데이터를 전달한다.
- ip 패킷 정보에 `출발지 ip`와 `목적지 ip`가 있어야한다.
- 인터넷 망에 해당 패킷을 던진다.
- 최종적으로 목적지 ip를 찾아간다.
- 서버도 같은 ip패킷을 만들어서 클라이언트에 던진다. (요청과 응답이 다른 경로로 갈 수 있다.)

### ip 프로토콜의 한계
- `비연결성` : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송한다. 이 때 클라이언트는 대상 서버가 어떤 상태인지 알 수 없다. 예를 들면 중간에 인터넷 망의 서버가 문제가 발생하여 해당 패킷이 유실되어도 클라이언트는 알 수 없다.

- `비신뢰성` : 패킷이 중간에 사라지거나 패킷이 순서대로 도착하지 않을 수 있다.

- `프로그램 구분` : 같은 ip를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면 구분하지 못한다. (port가 없다)

## TCP/UDP
ip 프로토콜의 한계를 해결할 수 있다.

### 인터넷 프로토콜 스택의 4계층
+ 애플리케이션 계층: HTTP, FTP ... 
+ 전송 계층 : TCP, UDP
+ 인터넷 계층 : IP
+ 네트워크 인터페이스 계층 : LAN 드라이버, LAN 장비

### 과정
1. 프로그램이 Hello, world! 메세지 생성
2. SOCKET 라이브러리를 통해 os계층에 전달
3. os계층에서 메세지 정보를 포함한 TCP 정보를 생성
4. TCP정보 위에 IP 패킷 생성
5. 네트워크 인터페이스를 통해 LAN카드를 통해서 나갈 때 이더넷 프레임을 생성해서 나간다.

### TCP/IP 패킷 정보
기존의 출발지 ip, 목적지 ip 뿐 만 아니라 출발지 port, 목적지 port, 전송 제어, 순서, 검증 정보 등을 데이터 위애 포함한다.

### TCP 특징
+ 전송 제어 프로토콜
+ 연결지향 - TCP 3 way handshake
+ 데이터 전달 보증
+ 순서 보장
- 따라서, 신뢰할 수 있는 프로토콜이다.

#### TCP 3 way handshake (연결 과정)
1. 클라이언트가 SYN을 서버에 보내면서 접속을 요청한다.
2. 서버가 ACK과 SYN을 클라이언트에게 보내면서 요청과 수락을 한다.
3. 클라이언트는 다시 ACK를 서버에 보내면서 요청을 수락하면서 데이터를 보낸다.

+ 물리적으로 연결된 것이 아닌 가상으로 연결된 것이다.

#### 데이터 전달 보증
데이터를 잘 전달 받았다고 클라이언트에게 보내준다.

#### 순서 보장
- 패킷을 전송한 순서를 보장해준다.
- 순서가 잘못 온 경우 잘못된 패킷부터 클라이언트에게 다시 보내라고 요청하고 클라이언트는 다시 보낸다.

### UDP 프로토콜
+ 기능이 거의 없다.
+ 연결 지향 X
+ 데이터 전달 보증 X
+ 순서 보장 X
+ `단순하고 빠르다.`
+ IP와 거의 같지만 `PORT`와 `체크섬` 정도만 추가되어 있다.
+ 애플리케이션에서 추가 작업 필요

#### PORT
같은 IP 내에서 프로세스를 구분하는 정보이다. 예를 들자면 ip가 아파트라면 port는 호 수이다.
+ 0 ~ 65535 할당 가능
+ 0 ~ 1023은 잘 알려진 포트로 사용하지 않는 것이 좋다.
+ FTP - 20, 21
+ TELNET - 23
+ HTTP - 80
+ HTTPS - 443

#### 체크섬
해당 데이터가 맞는치 체크해주는 정보

## DNS
도메인 네임 시스템
- 외우기 힘든 ip주소를 DNS로 만들면서 ip를 기억하지 않아도 된다.
- DNS 서버에 도메인을 등록할 수 있어 ip가 바뀌어도 해당 도메인만 알면 신규 ip로 접근이 가능하다.

## URI (Uniform Resurce Identifier)
자원을 분류하는 방법으로 URI는 locator, name 또는 둘 다 추가로 분류될 수 있다.

- Uniform : 리소스를 식별하는 통일된 방식
- Resource : URI로 식별할 수 있는 모든 것 (자원)
- Identifier : 다른 항목과 구분하는데 필요한 정보

### URL
Locator, 리소스의 위치를 지정

### URN
Name, 리소스에 이름을 부여
+ 장점 : 위치는 변할 수 있지만, 이름은 변하지 않는다.
+ 단점 : 이름을 부여하면 리소스를 찾을 수 없기 때문에 URL만 사용한다.

### URL 문법
```html
scheme://[userinfo@]host[:port][/path][?query][#fragment]
```
```html
"https://www.google.com:443/search?q=hello&hl=ko"
```

+ `scheme` : 프로토콜의 정보
+ `[userinfo@]` : URL에 사용자 정보를 포함해서 인증해야할 때 사용하지만 거의 사용하지 않는다.
+ `프로토콜` : `https`
    + 프로토콜 : 어떤 방식으로 자원에 접근할 것인지 클라이언트와 서버간의 약속 규칙
+ `호스트 명` : `www.google.com`
    + 도메인 이름 또는 ip주소를 직접 사용 가능
+ `포트 번호` : `443`
    + http는 80, https는 443 포트를 주로 사용하기 때문에 이 둘을 사용하면 포트를 생략할 수 있다.
+ `패스` : `/search` 
    + 리소스가 있는 경로, 계층적 구조로 되어있다.
    + `/members/100` : members 디렉토리의 100번 회원의 아이디를 본다고 할 때
+ `쿼리 파라미터` : `q=hello&hl=ko`
    + key = value의 형태로 되어있다.
    + ?로 시작, &로 추가해서 파라미터를 이어 붙있 수 있다.
    + 숫자를 포함한 모두 다 문자로 넘어가기 때문에 query string이라고도 불린다.
+ `#fragment` : 중간으로 이동할 수 있는 html의 내부 북마크 등으로 사용되며 서버에 전송되는 정보는 아니다.
    
### 웹 브라우저 요청의 흐름

#### 클라이언트
1. 링크를 웹 브라우저에게 요청한다.
2. DNS서버를 조회해서 ip와 port정보를 찾아낸다.
3. http 요청 메세지를 생성
4. socket 라이브러리를 통해 TCP/IP 연결(ip/port 이용해서 클라와 서버 연결) + TCP/IP로 데이터(http 요청 메세지) 전달
5. 데이터를 포함한 TCP/IP 패킷 생성
6. 인터넷 망으로 전달
7. 웹 브라우저가 서버로부터 받은 응답 메세지의 HTML을 렌더링해서 결과를 화면에 띄운다.

#### 서버
1. TCP/IP 패킷을 다 까서 버리고 http 메세지를 해석
2. http 메세지의 요청에 맞는 데이터를 찾아서 http 응답 메세지(html로 되어있는)를 생성
3. 데이터 위에 TCP/IP 패킷을 씌운다.
4. 클라이언트에게 해당 패킷을 보낸다.

## Reference
- 모든 개발자를 위한 HTTP 웹 기본 지식 [김영한]
