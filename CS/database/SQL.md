# SQL
관계 데이터베이스를 위한 표준 질의어
- 관계 데이터 연산은 절차적 언어, SQL은 비절차적 언어

## 1. SQL의 분류
- `데이터 정의어(DDL)`: 테이블을 생성하고 변경, 제거하는 기능을 제공
- `데이터 조작어(DML)`: 테이블에 새 데이터를 삽입하거나, 테이블에 저장된 데이터를 수정, 삭제, 검색하는 기능을 제공
- `데이터 제어어(DCL)`: 보안을 위해 데이터에 대한 접근 및 사용 권한을 사용자별로 부여하거나 취소하는 기능을 제공

## 2. SQL의 소개
- `DDL`: `CREATE`(테이블 생성), `ALTER`(테이블 변경), `DROP`(테이블 제거)
- `DML`: `SELECT`, `INSERT`, `UPDATE`, `DELETE`

## 3. 데이터 정의어

### 3.1 테이블 생성
- `[]`의 내용은 생략 가능
- SQL 질의문은 `세미클론(;)`으로 문장의 끝을 표시한다.
- SQL 질의문은 대소문자를 구분하지 않는다.

```sql
CREATE TABLE 테이블 이름 (
    속성_이름 데이터_타입 [NOT NULL] [DEFAULT 기본_값] // 속성, 데이터 타입, 기본 제약 사항 정의
    [PRIMARY KEY (속성_리스트)] // 기본키
    [UNIQUE (속성_리스트)] // 대체키
    [FOREIGN KEY (속성_리스트) REFERENCES 테이블_이름(속성_리스트)] [ON DELETE 옵션] [ON UPDATE 옵션] // 외래키
    [CONSTRAINT 이름] [CHECK(조건)] // 데이터 무결성을 위한 제약조건 
);
```

### 3.2 테이블 변경

#### 새로운 속성 추가

```sql
ALTER TABLE 테이블_이름 ADD 속성_이름 데이터_타입 [NOT NULL] [DEFAULT 기본_값];
```

#### 기존 속성 제거

```sql
ALTER TABLE 테이블_이름 DROP COLUMN 속성_이름 [CASCADE | CONSTRAINTS];
```
- `CASCADE`: 제거할 속성과 관련된 제약조건이나 참조하는 다른 속성을 함께 제거
- `CONSTRAINTS`: 제거할 속성과 관련된 제약조건이나 참조하는 다른 속성이 존재하면 제거 거부

#### 제약조건 추가/삭제

```sql
// 새로운 제약조건 추가
ALTER TABLE 테이블_이름 ADD CONTRAINT 제약조건_이름 제약조건_내용;

// 기존의 제약조건 삭제
ALTER TABLE 테이블_이름 DROP CONSTRAINT 제약조건_이름;
```

### 3.3 테이블 제거
```sql
DROP TABLE 테이블_이름 [CASCADE CONSTRAINTS];
```
- `CASCADE`: 제거할 테이블을 참조하는 다른 테이블도 함께 제거
- `CONSTRAINTS`: 제거할 테이블을 참조하는 다른 테이블이 존재하면 제거 거부

## 4. 데이터 조작어

### 4.1 데이터 검색: SELECT

#### 기본 검색
- `SELECT`키워드와 함께 검색하고 싶은 `속성`의 이름 나열
    + 모든 속성: `*`
- `FROM`키워드와 함께 검색하고 싶은 속성이 있는 `테이블`의 이름 나열
- `AS`키워드를 이용해 결과 테이블에서 속성의 이름을 바꾸어 출력 가능
    + ex. `SELECT 제품명, 단가 AS 가격 FROM 제품;`
- `산술 연산자`를 이용해 산술이 적용된 결과 테이블을 출력
    + 속성 값이 실제로 변경되는 것은 아님
    + ex. `SELECT 제품명, 단가 + 500 AS 조정단가 FROM 제품;`
- 검색 결과는 테이블 형태로 반환

```sql
SELECT [ALL | DISTINCT] 속성_리스트
FROM   테이블_리스트;
```
- `ALL`: 결과 테이블이 튜플의 중복을 허용하도록 지정, 생략하면 자동으로 ALL 지정
- `DISTINCT`: 결과 테이블이 튜플의 중복을 허용하지 않도록 지정

#### 조건 검색
- 조건을 만족하는 데이터만 검색
- `WHERE`키워드와 함께 비교 연산자와 논리 연산자를 이용한 검색 조건 제시
- 숫자뿐만 아니라 문자나 날짜 값을 비교하는 것도 가능
    + ex. `'2023-02-06' < '2025-02-06'`
- `비교 연산자`: `== -> =`, `!= -> <>` 외 나머지 동일 (<, >, <=, >=)
- `논리 연산자`: `AND`, `OR`, `NOT`

```sql
SELECT [ALL | DISTINCT] 속성_리스트
FROM   테이블_리스트
[WHERE 조건];
```

#### LIKE를 이용한 검색
- `LIKE`키워드를 이용해 부분적으로 일치하는 데이터를 검색
- 문자열을 이용하는 조건에만 사용 가능
- `%`: 0개 이상의 문자 (문자의 내용과 개수는 상관 없음)
- `_`: 한 개의 문자 (문자의 내용은 상관 없음)

```sql
LIKE'데이터%': 데이터로 시작하는 문자열(길이 상관 x)
LIKE'%데이터': 데이터로 끝나는 문자열(길이 상관 x)
LIKE'%데이터%': 데이터가 포함된 문자열
LIKE'%데이터___': 데이터로 시작하는 6자 길이의 문자열
LIKE'__한%': 세 번째 글자가 '한'인 문자열
```
```sql
// 고객 테이블에서 성이 김 씨인 고객의 고객이름, 나이, 등급, 적립금을 검색
SELECT 고객이름, 나이, 등급, 적립금 FROM 고객 WHERE 고객이름 LIKE '김%';
```

#### NULL을 이용한 검색
- `IS NULL`키워드를 이용해 검색 조건에서 특정 속성의 값이 널 값인지를 비교
- `IS NOT NULL`키워드를 이용하면 특정 속성의 값이 널 값이 아닌지를 비교

```sql
// 고객 테이블에서 나이가 아직 입력되지 않은 고객의 고객이름을 검색
SELECT 고객이름 FROM 고객 WHERE 나이 IS NULL;
```

#### 정렬 검색
- `ORDER BY`를 이용해 결과 테이블 내용을 사용자가 원하는 순서로 출력
- `ASC`: 오름차순(기본값)
- `DESC`: 내림차순

```sql
SELECT [ALL | DISTINCT] 속성_리스트
FROM   테이블_리스트
[WHERE 조건]
[ORDER BY 속성_리스트 [ASC | DESC]];
```

```sql
// 주문 테이블에서 수량이 10개 이상인 주문의 주문고객, 주문제품, 수량, 주문일자를 검색
// 단, 주문제품을 기준으로 오름차순, 수량을 기준으로 내림차순 정렬
SELECT 주문 고객, 주문제품, 수량, 주문일자
FROM   주문
WHERE  수량 >= 10
ORDER BY 주문제품 ASC, 수량 DESC;
```

#### 집계 함수를 이용한 검색
- 특정 속성 값을 통계적으로 계산한 결과를 검색하기 위해 집계 함수를 이용한다.
- 주의 사항
    - 집계 함수는 널인 속성 값은 제외하고 계산
    - 집계 함수는 `WHERE`절에서는 사용할 수 없고 `SELECT`나 `HAVING`에서만 사용 가능

- 집계 함수

|함수|의미|사용 가능한 속성 타입|
|:---:|:---:|:---:|
|COUNT|속성 값의 `개수`|모든 데이터|
|MAX|속성 값의 `최대값`|//|
|MIN|속성 값의 `최소값`|//|
|SUM|속성 값의 `합계`|숫자 데이터|
|AVG|속성 값의 `평균`|//|

```sql
// 제품 테이블에서 단가의 평균
SELECT AVG(단가)
FROM   제품;

// 제품 테이블에서 전체 고객의 수
SELECT COUNT(*) 고객수 // NULL이 없는 대상으로 지정하기 위해 * 또는 PK로 지정한다.
FROM   고객

// 제품 테이블에서 제조업체의 수(중복X)
SELECT COUNT(DISTINCT 제조업체) AS '제조업체 수'
FROM   제품
```

#### 그룹별 검색
- `GROUP BY`키워드를 이용해 특정 속성의 값이 같은 튜플을 모아 그룹을 만들고, 그룹별로 검색
    + 그룹을 나누는 기준이 되는 속성을 `SELECT`절에도 작성
- `HAVING`키워드를 함께 이용해 그룹에 대한 조건을 작성하는 것도 가능
- `집계 함수`를 이용한 조건은 `WHERE`절에는 작성할 수 없고 `HAVING`절에서 사용 가능
- `집계 함수`나 `GROUP BY` 절에 명시된 속성 외의 속성은 `SELECT`절에 작성 불가
```sql
SELECT [ALL | DISTINCT] 속성_리스트
FROM 테이블_리스트
[WHERE 조건]
[GROUP BY 속성_리스트 [HAVING 조건]]
[ORDER BY 속성_리스트 [ASC | DESC]];

// 제품 테이블에서 제품을 3개 이상 제조한 제조업체별로 제품의 개수와, 제품 중 가장 비싼 단가를 검색
SELECT   제조업체, COUNT(*) AS 제품수, MAX(단가) AS 최고가
FROM     제품
GROUP BY 제조업체 HAVING COUNT(*)>=3;
```

#### 여러 테이블에 대한 조인 검색
- `조인 검색`: 여러 개의 테이블을 연결하여 데이터를 검색하는 것
- `조인 속성`: 조인 검색을 위해 테이블을 연결해주는 속성
    + 연결하려는 테이블 간에 조인 속성의 이름은 달라도 되지만 도메인은 같아야한다.
    + 일반적으로 외래키가 조인 속성으로 이용된다.
- `FROM`절에 검색에 필요한 모든 테이블을 나열
- `WHERE`절에 조인 속성의 값이 같아야함을 의미하는 조인 조건을 제시
- 같은 이름의 속성이 서로 다른 테이블에 존재할 수 있기 때문에 `테이블.속성`로 표시해준다.

```sql
// 판매 데이터베이스에서 고명석 고객이 주문한 제품의 제품명을 검색
SELECT 제품.제품명
FROM   고객, 제품, 주문
WHERE  고객.고객이름 = '고명석' AND 고객.고객아이디 = 주문.주문고객 AND 제품.제품번호 = 주문.주문제품;
```

- `INNER JOIN .. ON` 문법을 사용

```sql

SELECT *
FROM   고객 INNER JOIN 주문 ON 고객.고객아이디 = 주문.주문고객
```

#### 부속 질의문을 이용한 검색
- `SELECT`문 안에 또 다른 `SELECT`문을 포함하는 질의
- `상위 질의문`: 다른 SELECT문을 포함하는 SELECT문
- `부속 질의문`: 다른 SELECT문 안에 내포된 SELECT문
    + 괄호로 묶어서 작성하고 `ORDER BY`절을 사용할 수 없다.
    + `단일 행 부속 질의문`: 하나의 행을 결과로 반환
    + `다중 행 부속 질의문`: 하나 이상의 행을 결과로 반환
- 부속 질의문을 먼저 수행하고, 그 결과를 이용해 상위 질의문을 수행
- 부속 질의문과 상위 질의문을 연결하는 연산자가 필요
    + 단일 행 부속 질의문: 비교 연산자 사용 가능
    + 다중 행 부속 질의문: 비교 연산자 사용 x

```sql
// 판매 데이터베이스에서 달콤비스켓과 같은 제조업체에서 제조한 제품의 제품명과 단가를 검색
SELECT 제품명, 단가
FROM   제품
WHERE  제조업체 = (SELECT 제조업체
                 FROM   제품
                 WHERE  제품명 = '달콤비스켓')
```

#### 다중 행 부속 질의문에서 상위 질의문을 연결하는 연산자

|연산자|설명|
|:---:|:---:|
|IN|부속 질의문의 결과 값 중 일치하는 것이 있으면 검색 조건이 참|
|NOT IN|부속 질의문의 결과 값 중 일치하는 것이 없으면 검색 조건이 참|
|EXISTS|부속 질의문의 결과 값이 하나라도 존재하면 검색 조건이 참|
|NOT EXISTS|부속 질의문의 결과 값이 하나도 존재하지 않으면 검색 조건이 참|
|ALL|부속 질의문의 결과 값 모두와 비교한 결과가 참이면 검색 조건을 만족 <br> (비교 연산자와 함께 사용)|
|ANY 또는 SOME|부속 질의문의 결과 값 중 하나라도 비교한 결과가 참이면 검색 조건을 만족 <br> (비교 연산자와 함께 사용)|

```sql
// 판매 데이터베이스에서 banana 고객이 주문한 제품의 제품명과 제조업체를 검색
SELECT 제품명, 제조업체
FROM   제품
WHERE  제품번호 IN (SELECT 주문제품
                  FROM   주문
                  WHERE  주문고객 = 'banana');
```

### 4.2 데이터 삽입: INSERT
- 해당 테이블에 데이터를 직접 삽입
- `INTO`키워드와 함께 튜플을 삽입할 테이블의 이름과 속성의 이름을 나열
    + 모든 속성을 지정할 때는 해당 테이블 이름만 지정해도 된다.
- `VALUES`키워드와 함께 삼입할 속성 값들을 나열
- `INTO`절의 속성 이름과 `VALUES`절의 속성 값은 순서대로 `1:1 매칭`이 되어야한다.

```sql
INSERT
INTO   테이블_이름[(속성_리스트)]
VALUES (속성값_리스트);

// 예시
INSERT
INTO   고객(고객아이디, 고객이름, 나이, 등급, 직업, 적립금)
VALUES ('strawberry', '최유경', 30, 'vip', '공무원', 100);
```

#### 부속 질의문을 이용한 데이터 삽입
```sql
INSERT
INTO   테이블_이름[(속성_리스트)]
SELECT 문;
```

```sql
// 한빛제과에서 제조한 제품의 제품명, 재고량, 단가를 제품 테이블에서 검색하여 한빛제품 테이블에 삽입
INSERT
INTO   한빛제품(제품명, 재고량, 단가)
SELECT 제품명, 제고량, 단가
FROM   제품
WHERE  제조업체 = '한빛제과';
```

### 4.3 데이터 수정: UPDATE
- 테이블에 저장된 튜플에서 특정 속성의 값을 수정
- `SET`키워드 다음에 속성 값을 어떻게 수정할 것인지를 지정
- `WHERE`절에 제시된 조건을 만족하는 튜플에 대해서만 속성 값을 수정
    + `WHERE`절을 생략하면 테이블에 존재하는 모든 튜플을 대상으로 수정

```sql
UPDATE 테이블_이름
SET    속성_이름1 = 값1, 속성_이름2 = 값2 ... 
[WHERE 조건];
```

```sql
// 제품 테이블에서 제품번호가 p03인 제품의 제품명을 통큰파이로 수정
UPDATE 제품
SET    제품명 = '통큰파이'
WHERE  제품번호 = `p03`
```

#### 부속 질의문을 이용한 데이터 수정
```sql
// 판매 데이터베이스에서 정소화 고객이 주문한 제품의 주문수량을 5개로 수정
UPDATE 주문
SET    수량 = 5
WHERE  주문고객 IN (SELECT 고객아이디
                  FROM   고객
                  WHERE  고객이름 = '정소화');
```

### 4.4 데이터 삭제: DELETE
- 테이블에 저장된 데이터를 삭제
- `WHERE`절에 제시한 조건을 만족하는 튜플만 삭제
    + `WHERE`절을 생략하면 테이블에 존재하는 모든 튜플을 삭제하여 빈 테이블이 된다.

```sql
DELETE
FROM   테이블_이름
[WHERE 조건];
```

#### 부속 질의문을 이용한 데이터 삭제
```sql
// 판매 데이터베이스에서 정소화 고객이 주문한 내역을 주문 테이블에서 삭제
DELETE
FROM   주문
WHERE  주문고객 IN (SELECT 고객아이디
                  FROM   고객
                  WHERE  고객이름 = '정소화');
```
