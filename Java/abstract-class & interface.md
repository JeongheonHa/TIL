# 추상클래스

## 1. 추상클래스
- 추상메서드를 포함하고 있는 클래스 (미완성 설계도)
- 호출할 때 필요한 것은 선언부이므로 일반메서드가 추상메서드 호출 가능.
- 완성된 메서드가 아니므로 객체 생성 x

## 2. 추상메서드
- header만 있고 body는 없는 메서드
- 꼭 필요한 메서드면서 자손마다 구현부가 다르게 구현될 것 같을 때 사용하면 좋다.
- 추상메서드를 상속은 자손 클래스에서 메서드를 완성시킨다.

# 인터페이스

## 1. 인터페이스
- 추상메서드의 집합 (부수적으로 상수, static method, default method를 포함한다)
- 실제 구현된 것이 전혀 없는 기본 설계도이다. (껍데기라고 생각하면 이해하기 쉽다)
- 두 객체간의 연결, 대화, 소통을 돕는 **중간다리 역할**이라고 생각하자.
- 인스턴스를 생성할 수 없다.
- 모든 멤버가 public이다.

## 2. 작성 예시
```java
interface 인터페이스 이름 {
  public static final 타입 상수이름 = 값; // <- 상수(부수적), **public static final은 항상동일!!(생략 가능)**
  public abstract 메서드이름(매개변수목록); // <- 추상메서드(핵심), **인터페이스의 모든메서드느 public abstract이므로 항상동일!!(생략가능)**
 }
```

## 3. 인터페이스의 상속
- 인터페이스 끼리만 상속 가능 (Object와 같은 최고 조상 x)
- class와 달리 다중상속이 허용된다.

## 4. 구현
```java
class 클래스잉름 implements 인터페이스이름 {  // class의 구현과 같다, 단지 extends냐 implements냐의 차이)
  // 인터페이스에 정의된 추상메서드 구현
}
```
- interface vs abstract class
  + interface느 인스턴스 변수를 가질 수 없다.
  + 오직 추상메서드, 상수, static method, default method만을 가진다.

- 상속과 구현 동시에 가능
```java
  class 클래스이름 extends 조상 클래스이름 implements 인터페이스이름 {
    public void method1() { /* 내용 */ } <- 조상 클래스에서 상속받은 메서드
    public void method2() { /* 내용 */ } <- 인터페이스에서 상속받은 메서드
}
```

## 5. 인터페이스를 이용한 다형성
- 인터페이스 타입의 변수로 인터페이스를 구현한 클래스의 인스턴스를 참조 가능
- 인터페이스를 메서드의 매개변수 타입으로 지정 가능
- 인터페이스를 메서드의 리턴타입으로 지정할 수 있다.   
  1. 반환타입이 interface라면
  2. 인터페이스를 구현한 class의 참조변수를 반환하고
  3. 호출 쪽에서 반환타입과 일치시킨다.

## 6. 인터페이스를 쓰면 좋은 점 5가지 !!
- 개발 시간 단축
- ### **변경에 유리한 유연한 설계가 가능 !!!!!!!** 
- 표준화 가능
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.
- 독립적인 프로그래밍 가능


## 7. default method (jdk1.8 추가)
- 인터페이스에 새로운 메서드를 추가하면 해당 인터페이스를 구현한 모든 클래스에서 추가한 메서드를 구현해주어야하는 불편함 존재했었고   
이 문제를 해결하기위해 추가한 기능이다.
- 추상메서드의 기본 구현을 제공하며 body를 가지고 있다.
- body를 가지기 때문에 충돌이 발생한다.  

## 8. default method 충돌
1. 여러 인터페이스의 디폴트 메서드 간의 충돌   
-> 오버라이딩한다.   
2. 디폴트 메서드와 조상 클래스의 메서드간의 충돌   
-> 조상클래스의 메서드가 상속 (디폴트 메서드 무시)
```java
interface MyInterface {
  void method();
  default void newMethod() {} // default를 앞에 붙이고 항상 public이다. (생략 가능)
```
# Reference
> 자바의 정석 - 남궁성
