# 웹 서버, 웹 애플리케이션 서버

## 1. 웹 서버
- HTTP 기반으로 동작
- 정적 HTML, CSS, JS, 이미지, 영상등 정적 리소스를 제공한다.
- ex) NGINX, APACHE

## 2. 웹 애플리케이션 서버(WAS)
- HTTP 기반 동작
- 웹 서버의 기능을 포함하면서 동적 리소스를 제공한다.
- 프로그램 코드를 실행해서 애플리케이션 로직 수행
- ex) 톰캣, Jetty, Undertow

## 3. 웹 서버 vs WAS
둘의 경계가 모호하기 때문에 WAS는 애플리케이션 코드를 실행하는데 특화된 서버이고 크게는 웹 서버는 정적 리소스를 WAS는 애플리케이션 로직을 실행하는 서버이다.

## 4. 웹 시스템 구성
클라이언트 -> 웹 서버 -> WAS -> DB
- 정적 리소스는 웹 서버가 처리하고 WAS는 애플리케이션 로직같은 동적인 처리만을 실행하여 WAS의 서버 과부하를 해소한다.
- WAS는 무거운 작업을 수행하영 장애가 발생할 확률이 크기 때문에 장애가 발생시 웹 서버에서 에러 메세지를 보낼 수도 있다.
- 정적인 리소스가 많이 사용되면 Web 서버를 증설하고 애플리케이션 리소스가 많이 사용되면 WAS를 증설함으로써 효율적인 리소스 관리가 가능해진다.

# 서블릿
웹 애플리케이션 서버를 구현할 때 의미있는 비즈니스 로직을 실행하는 부분을 제외한 나머지를 알아서 처리해준다.

```java
@WebServlet(name = "helloServlet", urlPartterns = "/hello")
public class HelloServlet extens HttpSetvlet {

    @Override
    protected void service(HttpServletRequest request, HttpServletResponese respense) {
        //애플리케이션 로직
    }
}
```
- urlPatterns(/hello)의 URL이 호출되면 서블릿 코드가 실행된다.
- HTTP 요청 정보를 편리하게 사용할 수 있는 HttpServletRequest를 제공한다.
- HTTP 응답 정보를 편리하게 제공할 수 있는 HttpServletResponse를 제공하여 원하는 정보를 response객체에 넣어주기만 하면 된다.

## 1. 과정
1. 웹브라우저에서 localhost:8080/hello라고 요청 메세지를 WAS에 보낸다.
2. WAS에서 HTTP 요청 메세지를 기반으로 requset와 response객체를 생성한 후 서블릿 객체를 호출한다.
3. 내가 만든 helloServlet라는 서블릿 객체에 두 객체를 파라미터로 넣고 실행 해준다.
4. WAS에서 만들었던 reponse객체를 바탕으로 HTTP 응답 메서지를 만든다. (in WAS)
5. 웹 브라우저에 HTTP 응답 메서지를 전달해 웹 브라우저에서 렌더링 후 화면을 출력한다.

## 2. 서블릿 컨테이너
톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 한다.
- 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 모두 관리해준다.
- 서블릿 객체는 싱글톤으로 관리된다.
    + request나 response객체는 매번 생성해야하지만 서블릿 객체는 비효율적이기 때문에 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용한다. (공유 변수 사용x)
- JSP도 서블릿으로 변환 되어서 사용된다.
- 동시 요청을 위한 `멀티 쓰레드` 처리를 지원해주기 때문에 개발자는 마치 싱글 쓰레드 프로그래밍을 하듯이 편리하게 소스 코드를 개발할 수 있다. (단, 싱글톤 객체의 공유 변수를 주의하도록 하자.)

### 서블릿 객체는 쓰레드가 호출해준다.

## 3. 쓰레드
쓰레드는 애플리케이션 코드를 순차적으로 실행해준다.
- 쓰레드는 한번에 하나의 코드 라인만 수행한다.

### 3.1 다중 요청의 경우
요청이 들어올 때마나 쓰레드를 생성해서 서블릿 객체를 호출하여 실행한다. 서블릿 객체가 종료되면 쓰레드를 제거한다.

### 3.2 요청마다 쓰레드를 생성 (비추)

#### 장점
- 동시 요청 처리 가능
- 리소스(cpu, 메모리)가 허용할 때 까지 처리가능
- 하나의 쓰레드가 지연 되어도, 나머지 쓰레드는 정상 동작 가능

#### 단점
- 쓰레드는 한번 생성될 때의 생성 비용이 매우 비싸기 때문에 응답 속도가 늦어진다.
- 컨텍스트 스위칭 비용이 발생
- 쓰레드의 생성에 제한이 없어 cpu, 메모리의 임계점을 넘는 많은 고객의 요청들이 오면 서버가 죽을 수 있다.

### 3.3 쓰레드 풀 (추천)
요청이 오면 쓰레드 풀에서 쓰레드를 가져다 쓰고 서블릿 객체의 실행이 종료가 되면 쓰레드를 쓰레드 풀에 반납한다.
- 쓰레드 풀의 쓰레드보다 많은 요청이 오면 대기시키거나 거절한다.
    - 대기: 쓰레드를 사용할 수 있는 요청들을 대기 시킨다.
    - 거절: 쓰레드를 사용할 수 없다고 요청을 거절한다.
- 생성 가능한 쓰레드의 최대치를 관리한다.

#### 장점
- 쓰레드가 미리 생성되어있어 쓰레드를 생성하고 종료하는 비용이 절약되어 응답 시간이 빠르다.
- 쓰레드의 최대치가 있어 너무 많은 요청이 와도 기존 요청들을 안전하게 처리할 수 있다.


## SSR 서버 사이드 렌더링
HTML 최종 결과를 서버에서 만들어서 웹 브라우저에 전달하는 방식
- 주로 정적인 화면에 사용한다.
- JSP, 타임리프
 
## CSR 클라이언트 사이드 렌더링
HTML 결과를 자바스크립트를 사용해서 웹 브라우저에서 동적으로 생성해서 적용하는 방식
- 주로 동적인 화면에 사용한다.
- 구글 지도, Gmail

### 과정
1. 웹 브라우저에서 서버에 HTML 요청을 한다.
2. 서버는 내용이 없는 HTML과 함께 애플리케이션에 대한 js 링크를 보내준다.
3. 웹 브라우저는 js를 서버에 요청한다.
4. 서버는 클라이언트 로직과 HTML 렌더링 코드를 포함한 js를 응답한다.
5. 웹 브라우저는 HTTP API 데이터를 서버에 요청한다.
6. 서버는 JSON 형태의 데이터를 웹 브라우저에 응답한다.

## Reference
> 스프링 핵심 원리 - 기본편 [김영한]
